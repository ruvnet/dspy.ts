/**
 * ProgramOfThought Module - DSPy.ts
 *
 * Implements the ProgramOfThought module that teaches the LM to output code
 * whose execution results will dictate the response.
 * Compatible with DSPy Python's dspy.ProgramOfThought module.
 *
 * Usage:
 *   const pot = new ProgramOfThought({
 *     name: 'MathSolver',
 *     signature: { ... }
 *   });
 *   const result = await pot.run({ problem: "Calculate 15 * 23 + 7" });
 */

import { Module } from '../core/module';
import { Signature } from '../core/signature';
import { getLM } from '../lm/base';
import { VM } from 'vm2';

export interface ProgramOfThoughtConfig {
  /**
   * Module name
   */
  name: string;

  /**
   * Input/output signature
   */
  signature: Signature;

  /**
   * Maximum code execution time in ms (default: 5000)
   */
  timeout?: number;

  /**
   * Whether to allow Node.js built-in modules (default: false)
   */
  allowBuiltins?: boolean;

  /**
   * Custom sandbox environment
   */
  sandbox?: Record<string, any>;

  /**
   * Maximum iterations for retry on error (default: 3)
   */
  maxRetries?: number;
}

export interface ProgramOfThoughtStep {
  thought: string;
  code: string;
  result: any;
  error?: string;
}

/**
 * ProgramOfThought Module
 *
 * This module teaches the LM to solve problems by generating executable code.
 * The code is executed in a sandboxed environment and the results are used
 * to produce the final answer.
 *
 * Useful for:
 * - Mathematical computations
 * - Data transformations
 * - Algorithmic problem solving
 * - Any task requiring precise calculations
 *
 * @example
 * ```typescript
 * const pot = new ProgramOfThought({
 *   name: 'Calculator',
 *   signature: {
 *     inputs: [{ name: 'problem', type: 'string', required: true }],
 *     outputs: [{ name: 'answer', type: 'number', required: true }]
 *   }
 * });
 *
 * const result = await pot.run({
 *   problem: "What is 15% of 240?"
 * });
 *
 * console.log(result.answer); // 36
 * console.log(result.code); // "const result = 240 * 0.15; result"
 * ```
 */
export class ProgramOfThought<TInput, TOutput> extends Module<
  TInput,
  TOutput & { code: string; steps: ProgramOfThoughtStep[] }
> {
  private timeout: number;
  private allowBuiltins: boolean;
  private sandbox: Record<string, any>;
  private maxRetries: number;

  constructor(config: ProgramOfThoughtConfig) {
    super({
      name: config.name,
      signature: config.signature,
      strategy: 'Predict',
    });

    this.timeout = config.timeout || 5000;
    this.allowBuiltins = config.allowBuiltins || false;
    this.sandbox = config.sandbox || {};
    this.maxRetries = config.maxRetries || 3;
  }

  /**
   * Run the ProgramOfThought module
   */
  async run(input: TInput): Promise<TOutput & { code: string; steps: ProgramOfThoughtStep[] }> {
    const lm = getLM();
    const steps: ProgramOfThoughtStep[] = [];
    let retries = 0;
    let lastError: string | undefined;

    while (retries < this.maxRetries) {
      try {
        // Build the prompt
        const prompt = this.buildPoTPrompt(input, lastError);

        // Get LM response
        const response = await lm.generate(prompt, {
          maxTokens: 1500,
          temperature: 0.1, // Low temperature for code generation
        });

        // Parse the response
        const parsed = this.parsePoTResponse(response);

        if (!parsed.code) {
          throw new Error('No code generated by LM');
        }

        // Execute the code
        const result = await this.executeCode(parsed.code);

        steps.push({
          thought: parsed.thought,
          code: parsed.code,
          result,
        });

        // Parse the output fields from the result
        const output = this.parseOutput(result);

        return {
          ...output,
          code: parsed.code,
          steps,
        } as any;
      } catch (error) {
        lastError = error instanceof Error ? error.message : String(error);
        steps.push({
          thought: '',
          code: '',
          result: null,
          error: lastError,
        });
        retries++;

        if (retries >= this.maxRetries) {
          throw new Error(`ProgramOfThought failed after ${this.maxRetries} retries: ${lastError}`);
        }
      }
    }

    throw new Error('Unexpected error in ProgramOfThought');
  }

  /**
   * Build the Program-of-Thought prompt
   */
  private buildPoTPrompt(input: TInput, previousError?: string): string {
    const inputFields = this.signature.inputs
      .map((field) => {
        const value = (input as any)[field.name];
        return `${field.name}: ${value}`;
      })
      .join('\n');

    const outputFields = this.signature.outputs.map((field) => field.name).join(', ');

    let prompt = `You are a code-generating AI. Your task is to solve the following problem by writing executable JavaScript code.

Problem:
${inputFields}

Instructions:
1. Think about how to solve this problem step-by-step
2. Write JavaScript code that computes the answer
3. The code should return the result as the last expression or store it in a variable called 'result'
4. Use only standard JavaScript features
${this.allowBuiltins ? '' : '5. Do NOT use require() or import statements'}

Expected outputs: ${outputFields}

Format your response as:
Thought: [Your reasoning about how to solve this]
Code:
\`\`\`javascript
[Your JavaScript code here]
\`\`\`
`;

    if (previousError) {
      prompt += `\n\nThe previous code attempt failed with error: ${previousError}\nPlease fix the issue and try again.`;
    }

    return prompt;
  }

  /**
   * Parse the LM response to extract thought and code
   */
  private parsePoTResponse(response: string): { thought: string; code: string } {
    let thought = '';
    let code = '';

    // Extract thought
    const lines = response.split('\n');
    let inThought = false;
    let thoughtLines: string[] = [];

    for (const line of lines) {
      if (line.match(/^Thought:/i)) {
        inThought = true;
        thoughtLines.push(line.replace(/^Thought:\s*/i, ''));
      } else if (line.match(/^Code:/i)) {
        break;
      } else if (inThought) {
        thoughtLines.push(line);
      }
    }

    thought = thoughtLines.join('\n').trim();

    // Extract code (prefer code blocks, fallback to any code after "Code:")
    const codeBlockMatch = response.match(/```(?:javascript|js)?\s*\n([\s\S]+?)```/);
    if (codeBlockMatch) {
      code = codeBlockMatch[1].trim();
    } else {
      const codeMatch = response.match(/Code:\s*\n?([\s\S]+?)(?=\n\n|$)/i);
      if (codeMatch) {
        code = codeMatch[1].trim();
      }
    }

    return { thought, code };
  }

  /**
   * Execute code in a sandboxed environment
   */
  private async executeCode(code: string): Promise<any> {
    return new Promise((resolve, reject) => {
      try {
        // Use vm2 for sandboxing if available, otherwise fall back to eval
        let vm: VM | null = null;

        try {
          vm = new VM({
            timeout: this.timeout,
            sandbox: {
              ...this.sandbox,
              Math,
              Date,
              Array,
              Object,
              String,
              Number,
              Boolean,
              JSON,
            },
            eval: false,
            wasm: false,
          });
        } catch (vmError) {
          // vm2 not available, use safer eval
          console.warn('vm2 not available, using eval with limited safety');
        }

        let result: any;

        if (vm) {
          // Use vm2 sandbox
          result = vm.run(`
            (function() {
              ${code}
              return typeof result !== 'undefined' ? result : undefined;
            })()
          `);
        } else {
          // Fallback to Function constructor (safer than eval)
          const func = new Function(`
            ${code}
            return typeof result !== 'undefined' ? result : undefined;
          `);

          // Execute with timeout
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Code execution timeout')), this.timeout);
          });

          result = Promise.race([Promise.resolve(func()), timeoutPromise]);
        }

        resolve(result);
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Parse the execution result into output fields
   */
  private parseOutput(result: any): Record<string, any> {
    const output: Record<string, any> = {};

    // If result is an object, try to map to output fields
    if (typeof result === 'object' && result !== null) {
      for (const field of this.signature.outputs) {
        if (field.name in result) {
          output[field.name] = result[field.name];
        }
      }

      // If we found all required fields, return
      const foundAllRequired = this.signature.outputs
        .filter((f) => f.required)
        .every((f) => f.name in output);

      if (foundAllRequired) {
        return output;
      }
    }

    // Otherwise, assign result to the first output field
    if (this.signature.outputs.length > 0) {
      const firstOutput = this.signature.outputs[0];
      output[firstOutput.name] = this.convertToType(result, firstOutput.type);
    }

    return output;
  }

  /**
   * Convert a value to a specific type
   */
  private convertToType(value: any, type: string): any {
    switch (type) {
      case 'number':
        return Number(value);
      case 'string':
        return String(value);
      case 'boolean':
        return Boolean(value);
      case 'array':
        return Array.isArray(value) ? value : [value];
      case 'object':
        return typeof value === 'object' ? value : { value };
      default:
        return value;
    }
  }
}
